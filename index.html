<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Unit Testing</title>
    <meta property="og:title" content="Unit Testing" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://swkmagdeburg.github.io/UnitTestWorkshop//featured-slide.jpg" />
    <meta property="og:url" content="https://swkmagdeburg.github.io/UnitTestWorkshop/" />
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/simple.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/monokai.css" />
    <link rel="stylesheet" href="./assets/theme/custom.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template">

# Unit Testing 
## von 0 auf TDD an einem Tag

![SWK-MD](img/swk-logo.png)  <!-- .element: width="30%" -->

</script></section><section ><section data-markdown><script type="text/template">
## Warum testen wir?

</script></section><section data-markdown><script type="text/template">
### Ein Auto auf dem Rollenprüfstand
* Tuner: die Leistung seines Fahrzeugs feststellen <!-- .element: class="fragment" -->
* TÜV: Feststellen der Farbe des Aufklebers für die Windschutzscheibe <!-- .element: class="fragment" -->
* Hersteller: sicherstellen das die vom Kraftfahrbundesamt/der EU vorgegebenen Spezifikationen eingehalten werden <!-- .element: class="fragment" -->

</script></section><section data-markdown><script type="text/template">
### Warum testen wir?
* Systematische Ermittlung der Fähigkeiten eines Testgegenstandes <!-- .element: class="fragment" -->
* Übereinstimmung des Testgegenstandes mit einer Spezifikation sicherstellen <!-- .element: class="fragment" -->

</script></section><section data-markdown><script type="text/template">
### Unit Tests
* Testgegenstand ist eine Methode, Klasse oder Komponente (Verbund von Klassen) <!-- .element: class="fragment" -->
* definieren unterschiedliche Testfälle <!-- .element: class="fragment" -->
  * können fachlich vorgegeben sein
  * je Testfall Erwartungswert
  * je Testfall Rahmenbedingungen (über korrekte Initialisierung)
* stellen sicher, dass Erwartungswerte mit realen Werten übereinstimmen <!-- .element: class="fragment" -->

</script></section><section data-markdown><script type="text/template">
### Wie wird getestet?

<div id="left">

Definieren von: <!-- .element: class="fragment" data-fragment-index="1" -->
* Rahmenbedingungen <!-- .element: class="fragment" data-fragment-index="1" -->
* Eingangswerte <!-- .element: class="fragment" -->
* erwartete Ausgangswerte <!-- .element: class="fragment" -->

</div>

<div id="right" class="fragment">

<img src='https://g.gravizo.com/svg?@startuml;left to right direction;;node "System\nUnder\nTest" as sut;card a;card b;card c;;a --> sut;b --> sut;sut --> c;@enduml'/>

</div>

</script></section><section data-markdown><script type="text/template">
### Was zeichnet einen guten Unit Test aus?

* Schnelligkeit <!-- .element: class="fragment" -->
  * Ausführung innerhalb von Millisekunden
  * oftmals mehrere tausend Unit Tests in größeren Projekten
* Unabhängigkeit <!-- .element: class="fragment" -->
  * sind eigenständig und können isoliert ausgeführt werden
  * keine Abhängigkeiten zu externen Quellen (Dateisystem, Datenbanken, ...)
* Wiederholbarkeit <!-- .element: class="fragment" -->
  * Jeder Lauf eines Unit Tests führt immer zum gleichen Ergebnis
* Selbtsprüfung <!-- .element: class="fragment" -->
  * Der Test prüft selbständig, ob er erfolgreich war oder nicht
* Verhältnismäßigkeit <!-- .element: class="fragment" -->
  * Aufwand zum Schreiben der Tests muss im Verhältnis zum produktiven Code stehen
  * Aufwändig zu schreibende Tests weisen oft auf ungeeigneten Entwurf im Code hin
  
</script></section><section data-markdown><script type="text/template">
### Beispiele in Java
```java
@Test
public void EncryptShouldHandleEmptyString() {
    // Arrange
    var sut = new Rot13Security();

    // Act
    var actual = sut.Encrypt("");

    // Assert
    assertEquals("", actual);
}
```

```java
@BeforeEach
public void SetUp() {
    _sut = new Rot13Security();
}

@Test
public void EncryptShouldNotShiftSpecialCharacters() {
    var specialCharacters = "01234567890, !§$%&/()=[]{}";
    assertEquals(specialCharacters, _sut.Encrypt(specialCharacters));
}
```

</script></section><section data-markdown><script type="text/template">
### Beispiele in C#

```csharp
[Test]
public void EncryptShouldHandleEmptyString()
{
    // Arrange
    var sut = new Rot13Security();

    // Act
    var actual = sut.Encrypt(string.Empty);

    // Assert
    Assert.That(actual, Is.EqualTo(string.Empty));
}
```

```csharp
[Test]
public void EncryptShouldNotShiftSpecialCharacters()
{
    var specialCharacters = "01234567890, !§$%&/()=[]{}";
    Assert.That(_sut.Encrypt(specialCharacters), Is.EqualTo(specialCharacters));
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background="img/practice.svg" data-background-size="40%" -->

### Übung - mit Unit Tests vertraut machen

* [swkMagdeburg/UnitTestWorkshop](https://github.com/swkMagdeburg/UnitTestWorkshop)
* Was: Beispielimplementierung der [Function Kata ROT-13](https://ccd-school.de/coding-dojo/function-katas/rot-13/)
* Ziele:
  * Test Runner laufen lassen
  * Struktur von Test- und Produktivcode erkunden
  * Produktiven Code ändern und Tests beobachten
  * Erste eigene Testfälle schreiben 

</script></section></section><section ><section data-markdown><script type="text/template">
## Unit Tests nutzen

</script></section><section data-markdown><script type="text/template">
### Wo helfen uns Unit Tests?

* Dokumentieren die fachlichen Anforderungen <!-- .element: class="fragment" -->
* Dokumentieren die Verwendung des produktiven Codes <!-- .element: class="fragment" -->
* Unterstützen beim Entwerfen vom Design <!-- .element: class="fragment" -->
* Verifizieren fortlaufend! die Korrektheit des Codes <!-- .element: class="fragment" -->
* Geben Sicherheit für Erweiterungen und Refactoring <!-- .element: class="fragment" -->

</script></section><section data-markdown><script type="text/template">
### Übung - Refactoring mit Unit Tests
<!-- .slide: data-background="img/practice.svg" data-background-size="40%" -->

* Was: [Tennis Refactoring Kata](https://github.com/emilybache/Tennis-Refactoring-Kata)
* Ziele:
  * Implementierung verstehen
  * Refactoring für bessere Lesbarkeit
  * Tests müssen nicht angepasst / erweitert werden

</script></section></section><section ><section data-markdown><script type="text/template">
## Unit Tests schreiben

</script></section><section data-markdown><script type="text/template">
### Dirty Tests

* sind schwer wartbar <!-- .element: class="fragment" -->
* macht Produktivcode schwerer wartbar, da Tests mit gepflegt werden müssen <!-- .element: class="fragment" -->
* typische Symptome <!-- .element: class="fragment" -->
  * viele gleiche Tests mit nur subtilen Änderungen <!-- .element: class="fragment" -->
  * ein Refactoring verursacht viele fehlschlagende Tests <!-- .element: class="fragment" -->

</script></section><section data-markdown><script type="text/template">
### Test Code ist (fast) wichtiger als Produktivcode

* aus Test Code lässt sich Produtktivcode wieder herstellen <!-- .element: class="fragment" -->
* dokumentiert unser System <!-- .element: class="fragment" -->
* verifiziert Korrektheit des Produktivcodes <!-- .element: class="fragment" -->
* baut Sicherheitsnetz für Erweiterungen und Anpassungen auf <!-- .element: class="fragment" -->

</script></section><section data-markdown><script type="text/template">
### Halte deine Tests sauber

* Tests sollten analog zum Produktivcode <!-- .element: class="fragment" -->
  * lesbar 
  * verständlich 
  * einfach 
  * flexibel 
  * frei von Duplikationen 

</script></section><section data-markdown><script type="text/template">
### Nutze aussagekräftige Testnamen
![](img/jenkins.png)

</script></section><section data-markdown><script type="text/template">
### Nutze aussagekräftige Testnamen
![](img/AzureDevOpsPipeline.png)

</script></section><section data-markdown><script type="text/template">
### Baue jeden Test gleich auf

<div id="left" class="fragment">

* Triple A
  * Arrange
  * Act
  * Assert
</div>

<div id="right" class="fragment">

* BDD - Behavior Driven
  * Given
  * When
  * Then
</div>


</script></section><section data-markdown><script type="text/template">
### Baue jeden Test gleich auf
```java
@Test
public void EncryptShouldHandleEmptyString() {
    // Arrange
    var sut = new Rot13Security();

    // Act
    var actual = sut.Encrypt("");

    // Assert
    assertEquals("", actual);
}
```

```csharp
[Test]
public void EncryptShouldHandleEmptyString()
{
    // Arrange
    var sut = new Rot13Security();

    // Act
    var actual = sut.Encrypt(string.Empty);

    // Assert
    Assert.That(actual, Is.EqualTo(string.Empty));
}
```

</script></section><section data-markdown><script type="text/template">
### Nutze statische Imports

```java
@Test
public void EncryptShouldHandleNull() {
    Assertions.assertEquals("", _sut.Encrypt(null));
}
```
<!-- .element: class="fragment" -->

```java
import static org.junit.jupiter.api.Assertions.assertEquals;

@Test
public void EncryptShouldHandleNull() {
    assertEquals("", _sut.Encrypt(null));
}
```
<!-- .element: class="fragment" -->

</script></section><section data-markdown><script type="text/template">
### Vertausche nicht expected und actual
```csharp
[TestCase("N", "A")]
public void EncryptShouldShiftToStartOfAlphabetWhenItsEndIsReached(string character, string expected)
{
    Assert.AreEqual(_sut.Encrypt(character), expected);
}
```
<!-- .element: class="fragment" -->

```
String lengths are both 1. Strings differ at index 0.
Expected: "["
But was:  "A"
-----------^
```
<!-- .element: class="fragment" -->

</script></section><section data-markdown><script type="text/template">
### Nutze Assert.That aus NUnit

```csharp
[TestCase("N", "A")]
[TestCase("O", "B")]
[TestCase("Z", "M")]
public void EncryptShouldShiftToStartOfAlphabetWhenItsEndIsReached(string character, string expected)
{
    Assert.That(_sut.Encrypt(character), Is.EqualTo(expected));
}
```
<!-- .element: class="fragment" -->


</script></section><section data-markdown><script type="text/template">
### Fange keine Exceptions im Test

```java
@Test
public void EncryptShouldThrowExceptionWhenNull() {
    try {
        _sut.Encrypt(null);
    }
    catch (NullPointerException e) {
        return;
    }
    assertTrue(false);
}
```
<!-- .element: class="fragment" -->

```java
@Test
public void EncryptShouldThrowExceptionWhenNull() {
    assertThrows(NullPointerException.class, () -> _sut.Encrypt(null));
}
```
<!-- .element: class="fragment" -->

</script></section><section data-markdown><script type="text/template">
### Fange keine Exceptions im Test

```csharp
[Test]
public void EncryptShouldThrowExceptionWhenNull()
{
    try
    {
        _sut.Encrypt(null);
    }
    catch (ArgumentNullException e)
    {
        return;
    }
    Assert.Fail();
}
```
<!-- .element: class="fragment" -->

```csharp
[Test]
public void EncryptShouldThrowExceptionWhenNull()
{
    Assert.Throws<ArgumentNullException>(() => _sut.Encrypt(null));
}
```
<!-- .element: class="fragment" -->

</script></section><section data-markdown><script type="text/template">
### Nutze Parametrisierung von Tests

```java
@Test
public void EncryptShouldShiftUpperCaseCharacter() {
    assertAll(
            () -> assertEquals("N", _sut.Encrypt("A")),
            () -> assertEquals("O", _sut.Encrypt("B")),
            () -> assertEquals("P", _sut.Encrypt("C")),
            () -> assertEquals("Z", _sut.Encrypt("M"))
    );
}
```
<!-- .element: class="fragment" -->

```java
@ParameterizedTest
@CsvSource({
        "A, N",
        "B, O",
        "C, P",
        "M, Z"
})
public void EncryptShouldShiftUpperCaseCharacter(String character, String expected) {
    assertEquals(expected, _sut.Encrypt(character));
}
```
<!-- .element: class="fragment" -->

</script></section><section data-markdown><script type="text/template">
### Nutze Parametrisierung von Tests

```csharp
[Test]
public void EncryptShouldShiftUpperCaseCharacter()
{
    Assert.Multiple(() =>
    {
        Assert.That(_sut.Encrypt("A"), Is.EqualTo("N"));
        Assert.That(_sut.Encrypt("B"), Is.EqualTo("O"));
        Assert.That(_sut.Encrypt("C"), Is.EqualTo("P"));
        Assert.That(_sut.Encrypt("M"), Is.EqualTo("Z"));
    });
}
```
<!-- .element: class="fragment" -->

```csharp
[TestCase("A", "N")]
[TestCase("B", "O")]
[TestCase("C", "P")]
[TestCase("M", "Z")]
public void EncryptShouldShiftUpperCaseCharacter(string character, string expected)
{
    Assert.That(_sut.Encrypt(character), Is.EqualTo(expected));
}
```
<!-- .element: class="fragment" -->

</script></section><section data-markdown><script type="text/template">
### Übung - Unit Tests schreiben
<!-- .slide: data-background="img/practice.svg" data-background-size="40%" -->

* Was: [Gilded Rose Refactoring Kata](https://github.com/emilybache/GildedRose-Refactoring-Kata)
* Ziele:
  * Implementierung verstehen
  * Tests für funktionale Anforderungen erstellen
  * Test Coverage beachten
  * Produktiver Code muss nicht angepasst / erweitert werden

</script></section></section><section ><section data-markdown><script type="text/template">
## Test-Driven-Development (TDD)

</script></section><section data-markdown><script type="text/template">
### Ziel

* unzureichende Testabdeckung bei klassischer Entwicklung <!-- .element: class="fragment" -->
  * Tests werden parallel zum oder nach dem System entwickelt <!-- .element: class="fragment" -->
  * es besteht Zeit-/Kostendruck <!-- .element: class="fragment" -->
  * Testerstellung wird als erstes gestrichen <!-- .element: class="fragment" -->
* TDD durchbricht den Zyklus <!-- .element: class="fragment" -->
  * schreibe erst den Test, dann den Produktivcode <!-- .element: class="fragment" -->

</script></section><section data-markdown><script type="text/template">
### Vorgehensweise

<div id="left" class="fragment">

![](img/RedGreenRefactor.svg)

</div>
 <!-- .element: class="fragment" -->

<div id="right">

* Red: Testfall für neue Funktionalität <!-- .element: class="fragment" -->
  * Test muss fehl schlagen
  * Red nicht durch NotImplementedException
* Green: Produktivcode für Test  <!-- .element: class="fragment" -->
  * Minimalistische Umsetzung 
  * Test läuft grün durch
* Refactor: Produktiv- und Testcode <!-- .element: class="fragment" -->
  * Code umstellen falls notwendig
  * Keine neue Funktionalität schreiben

</div>

</script></section><section data-markdown><script type="text/template">
### Vorteile von TDD
* kein ungetesteter Code <!-- .element: class="fragment" -->
* hohe Testabdeckung <!-- .element: class="fragment" -->
* rechtzeitige Refaktorisierungen <!-- .element: class="fragment" -->
* Refaktorisierbarer Codebasis <!-- .element: class="fragment" -->
* stärkere Modularisierung <!-- .element: class="fragment" -->
* kein unnötiger Code <!-- .element: class="fragment" -->

</script></section><section data-markdown><script type="text/template">
### Nachteile von TDD
* TDD ist leicht zu erlernen, jedoch schwierig zu meistern <!-- .element: class="fragment" -->
* Benötigt viel Training <!-- .element: class="fragment" -->
* Erfordert Disziplin beim Entwickeln <!-- .element: class="fragment" -->

</script></section><section data-markdown><script type="text/template">
### Übung - TDD für Einsteiger
<!-- .slide: data-background="img/practice.svg" data-background-size="40%" -->

* Was: [Function Kata “Tannenbaum”](https://ccd-school.de/coding-dojo/function-katas/tannenbaum/)
* Ziele:
  * Erste Erfahrungen mit TDD machen
  * Rot - Grün - Refactor streng einhalten
  * Probleme und Benefits herausfinden

</script></section><section data-markdown><script type="text/template">
### Übung - TDD für Fortgeschrittene
<!-- .slide: data-background="img/practice.svg" data-background-size="40%" -->

* Was: [Class Kata “Bowling”](https://ccd-school.de/coding-dojo/class-katas/bowling/)
* Ziele:
  * TDD beim Erstellen einer ganzen Klasse nutzen
  * Rot - Grün - Refactor streng einhalten
  * Babysteps üben

</script></section><section data-markdown><script type="text/template">
### Übung - TDD für Experten
<!-- .slide: data-background="img/practice.svg" data-background-size="40%" -->

* Was: [Game of life](https://codingdojo.org/kata/GameOfLife/)
* Ziele:
  * TDD beim Erstellen von mehreren Klassen nutzen
  * Rot - Grün - Refactor streng einhalten
  * Babysteps verfestigen
  * Integrationstests schreiben

</script></section></section><section ><section data-markdown><script type="text/template">
## Was kommt da noch?

</script></section><section data-markdown><script type="text/template">
### Reichen Unit Tests aus?

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background="https://media.giphy.com/media/vvLWidwZNYH5e/giphy.gif"-->

</script></section><section data-markdown><script type="text/template">
### Unit Tests allein reichen nicht

* &shy;<!-- .element: class="fragment" --> **Unit Tests** testen einzelne Komponenten
* &shy;<!-- .element: class="fragment" --> **Integrationstests** testen Zusammenspiel von Komponenten 
* &shy;<!-- .element: class="fragment" --> **Systemtests** testen das gesamte System 
* &shy;<!-- .element: class="fragment" --> **UITests** testen das gesamte System über die UI

</script></section><section data-markdown><script type="text/template">
### Testpyramide

<div id="left">

* *Metapher für optimale Balance der Softwaretests
* Unit Tests haben darin den größten Anteil
* Service Tests beinhalten Api-, Integrations- und Systemtests
* UI Tests sind automatisierte Klicktests

</div>

<div id="right">

![](img/test-pyramid.png)
[Martin Fowler - TestPyramid](https://martinfowler.com/bliki/TestPyramid.html)

</div>

</script></section><section data-markdown><script type="text/template">
### Wie geh ich mit Abhängigkeiten um?

* Fast alle Komponenten haben Abhängigkeiten zu anderen <!-- .element: class="fragment" -->
* verursachen unerwartete Seiteneffekte <!-- .element: class="fragment" -->
* potenziert Testfälle <!-- .element: class="fragment" -->
* testen ist zum Teil unmöglich <!-- .element: class="fragment" -->

</script></section><section data-markdown><script type="text/template">
### Wie handhabe ich Abhängigkeiten?

Dependency Injection <!-- .element: class="fragment" -->

<div id="left">

![](img/DependencyInjection.svg)

</div>
 <!-- .element: class="fragment" -->

<div id="right">

* Abhängigkeiten injezieren <!-- .element: class="fragment" -->
* Produktivlauf nutzt Produktivcode der Abhängigkeit <!-- .element: class="fragment" -->
* Teslauf nutzt Ersatz für Produktivcode der Abhängigkeit <!-- .element: class="fragment" -->

</div>

</script></section><section data-markdown><script type="text/template">
### Mocking Frameworks helfen

* Java <!-- .element: class="fragment" -->
  * [JMock](http://jmock.org/)
  * [Mockito](https://site.mockito.org/)
  * [PowerMock](https://github.com/powermock/powermock)
* C# / .NET <!-- .element: class="fragment" -->
  * [NSubstitute](https://nsubstitute.github.io/)
  * [Rhino Mocks](https://www.hibernatingrhinos.com/oss/rhino-mocks)
  * [moq](https://github.com/moq/moq)
  * [Microsoft Fakes](https://docs.microsoft.com/de-de/visualstudio/test/isolating-code-under-test-with-microsoft-fakes?view=vs-2019)

</script></section><section data-markdown><script type="text/template">
## Wie bleibe ich mit TDD am Ball?

### Regelmäßiges Üben <!-- .element: class="fragment" -->

* &nbsp;<!-- .element: class="fragment" --> Coding Dojos
* &nbsp;<!-- .element: class="fragment" --> Coding Katas
  * [CCD School](https://ccd-school.de/coding-dojo/#cd2)
  * [Kata Log](https://kata-log.rocks/)
  * [Coding Dojo](https://codingdojo.org/)
* &nbsp; <!-- .element: class="fragment" --> [Code Retreats](https://www.coderetreat.org/)
* &nbsp; <!-- .element: class="fragment" --> Coding Dojos in der [SWK Magdeburg](https://www.meetup.com/de-DE/Softwerkskammer-Magdeburg/)

</script></section></section><section  data-markdown><script type="text/template">

## Vielen Dank!

![SWK-MD](img/swk-logo.png)  <!-- .element: width="20%" -->

<i class="demo-icon icon-rss">&nbsp;</i> [SWK Magdeburg](https://www.meetup.com/de-DE/Softwerkskammer-Magdeburg/)

<i class="demo-icon icon-twitter">&nbsp;</i> [@swkMagdeburg](https://twitter.com/swkMagdeburg)

<div id="left">

### Andreas Richter

* <i class="demo-icon icon-github-circled">&nbsp;</i> [anrichter](https://github.com/anrichter)
* <i class="demo-icon icon-twitter">&nbsp;</i> [@anrichter](https://twitter.com/anrichter)
* <i class="demo-icon icon-email">&nbsp;</i> [ar@anrichter.net](mailto:ar@anrichter.net)

</div>


<div id="right">

### Tobias Blaschke

* <i class="demo-icon icon-github-circled">&nbsp;</i> [gaerfield](https://github.com/gaerfield)
* <i class="demo-icon icon-twitter">&nbsp;</i> [@gaerfield](https://twitter.com/gaerfield)

</div>


</script></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"controls":false,"slideNumber":false,"transition":"slide","backgroundTransition":"fade"}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
